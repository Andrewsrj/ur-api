import { HttpException, HttpStatus, Injectable } from '@nestjs/common';
import * as admin from 'firebase-admin';
import { Post } from './Post';

@Injectable()
export class PostsService {

    /**
     * Recebe um objeto do tipo Post com apenas UID do Autor e relaciona com dados atualizados
     * @param data - Post object Array sem os dados atualizados do Autor, apenas com UID
     * @returns newdata - Post object Array com os dados atualizados do Autor
     */
    private async fetchDataUser(data) {
        const newData = [];
        var auth = admin.auth();
        await Promise.all(data.map(async (child) => {
            await auth
                .getUser(child.author.id)
                .then((userRecord) => {
                    // See the UserRecord reference doc for the contents of userRecord.
                    const authorData = { id: userRecord.uid, name: userRecord.displayName, image: userRecord.photoURL ? userRecord.photoURL : "undefined", verified: userRecord.emailVerified };
                    child.author = authorData;
                    newData.push(child);
                })
                .catch((error) => {
                    console.log('Error fetching user data:', error);
                });
        }))
        return newData;
    }
    /**
     * Busca todos os Posts no Database e relaciona com os dados do autor
     * @param token - Token de autenticação do usuário
     * @returns newdata - Post object com dados atualizados do autor
     */
    async findAll(token: string): Promise<any> {
        const verifyId = await this.verifyToken(token);
        if (!verifyId) {
            console.log("Access Denied!")
            throw new HttpException('Access Denied!', HttpStatus.UNAUTHORIZED);
        }
        console.log(this.verifyToken(token))
        // As an admin, the app has access to read and write all data, regardless of Security Rules
        var db = admin.database();
        var ref = db.ref("feed");
        var data = [];
        await ref.once("value", async function (snapshot) {
            snapshot.forEach((child) => {
                data.push(child.val());
            })
            await Promise.all(data);
        });
        return this.fetchDataUser(data);
    }
    /**
     * 
     * @param token - Token de autenticação do usuário
     * @param id - Unique ID do Post
     * @returns data - Post Object 
     */
    async findById(token: string, id: string): Promise<any> {
        const verifyId = await this.verifyToken(token);
        if (!verifyId) {
            console.log("Access Denied!")
            throw new HttpException('Access Denied!', HttpStatus.UNAUTHORIZED);
        }
        var db = admin.database();
        var ref = db.ref("feed");
        var data = [];
        await ref.orderByKey().equalTo(id).once('value', async function (snapshot) {
            console.log(snapshot.val());
            data = snapshot.val();
        });
        return data;
    }
    /**
     * Cria um novo Post
     * @param token - Token de autenticação do usuário
     * @param post - Post Object
     */
    async create(/*token: string,*/ post: Post) {
        /*const verifyId = await this.verifyToken(token);
        if (!verifyId) {
            console.log("Access Denied!")
            throw new HttpException('Access Denied!', HttpStatus.UNAUTHORIZED);
        }*/
        var db = admin.database();
        var ref = db.ref("feed");
        const newPost = ref.push();
        // Get the unique key generated by push()
        const postId = newPost.key;
        var refChild = db.ref("feed/" + postId);
        console.log("id:", postId);
        newPost.set(post, (error) => {
            if (error) {
                console.log(error);
            } else {
                refChild.update({ "id": postId });
                console.log(post);
            }
        });

    }

    private async verifyToken(tokenId: string) {
        if (!tokenId) {
            console.log(tokenId)
            return false;
        }
        var auth = admin.auth();
        return auth.verifyIdToken(tokenId)
            .then((decodedToken) => {
                const uid = decodedToken.uid
                return uid
            })
            .catch(() => { return false })
    }
}
